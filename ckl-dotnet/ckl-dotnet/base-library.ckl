# this is the base library of the checkerlang language

"
is_list(obj) 

Returns TRUE if the object is of type list.

: is_list([1, 2, 3]) ==> TRUE
"
def is_list(obj) type(obj) == 'list';


"
is_string(obj) 

Returns TRUE if the object is of type string.

: is_string('abc') ==> TRUE
"
def is_string(obj) type(obj) == 'string';


"
is_int(obj) 

Returns TRUE if the object is of type int.

: is_int(123) ==> TRUE
"
def is_int(obj) type(obj) == 'int';


"
is_decimal(obj) 

Returns TRUE if the object is of type decimal.

: is_decimal(123.45) ==> TRUE
"
def is_decimal(obj) type(obj) == 'decimal';


"
is_numeric(obj) 

Returns TRUE if the object is of type numeric. Numeric
types are int and decimal.

: is_numeric(123) ==> TRUE
: is_numeric(123.45) ==> TRUE
"
def is_numeric(obj) is_int(obj) or is_decimal(obj);


"
is_boolean(obj) 

Returns TRUE if the object is of type boolean.

: is_boolean(1 == 2) ==> TRUE
"
def is_boolean(obj) type(obj) == 'boolean';


"
is_set(obj) 

Returns TRUE if the object is of type set.

: is_set(set([1, 2, 3])) ==> TRUE
"
def is_set(obj) type(obj) == 'set';


"
is_map(obj) 

Returns TRUE if the object is of type map.

: is_map(map([['a', 1], ['b', 2]])) ==> TRUE
"
def is_map(obj) type(obj) == 'map';


"
is_func(obj) 

Returns TRUE if the object is of type func.

: is_func(fn(x) 2 * x) ==> TRUE
: is_func(sum) ==> TRUE
"
def is_func(obj) type(obj) == 'func';


"
non_zero(a, b) 

Returns the value a, if a is a non-zero integer, otherwise returns b.

: non_zero(1, 2) ==> 1
: non_zero(0, 2) ==> 2
"
def non_zero(a, b) do
  if int(a) == 0 then b
  else a
end;


"
non_empty(a, b) 

Returns the value a, if a is a non-empty string, otherwise returns b.

: non_empty('a', 'b') ==> 'a'
: non_empty('', 'b') ==> 'b'
"
def non_empty(a, b) do
  if a == '' then b
  else a
end;


"
identity(a) 

Identity function. It returns the input value as return value.

: identity(1) ==> 1
"
def identity(a) a;


"
const(val) 

Returns a function that returns a constant value, regardless of the argument used.

: def f = const(2); f(1) ==> 2
: def f = const(2); f('x') ==> 2
"
def const(val) fn(a) val;


"
min(a, b, key = identity) 

Returns the minimum of the values a, b. The optional key parameter takes a
function with one parameter, which is used to get the value from a and b
that is used for the comparison. Default key is the identity function.

: min(1, 2) ==> 1
: min([1, 'z'], [2, 'a'], key = fn(x) x[1]) ==> [2, 'a']
"
def min(a, b, key = identity) do
  if key(a) < key(b) then a
  else b
end;


"
max(a, b, key = identity) 

Returns the maximum of the values a, b. The optional key parameter takes a
function with one parameter, which is used to get the value from a and b
that is used for the comparison. Default key is the identity function.

: max(1, 2) ==> 2
: max([1, 'z'], [2, 'a'], key = fn(x) x[1]) ==> [1, 'z']
"
def max(a, b, key = identity) do
  if key(a) > key(b) then a
  else b
end;


"
abs(n) 

Returns the absolute value of n.

: abs(2) ==> 2
: abs(-3) ==> 3
"
def abs(n) do
  if is_null(n) then NULL
  if not is_numeric(n) then error(string(n) + " is not numerical")
  if n < 0 then - n 
  else n
end;

"
sign(n) 

Returns the signum of n

: sign(2) ==> 1
: sign(-3) ==> -1
"
def sign(n) do
  if is_null(n) then NULL
  if not is_numeric(n) then error(string(n) + " is not numerical")
  if n < 0 then -1
  if n > 0 then 1 
  else 0;
end;


"
first(lst) 

Returns the first element of a list.

: first([1, 2, 3]) ==> 1
: first(NULL) ==> NULL
"
def first(lst) do
  if is_null(lst) then NULL
  if not is_list(lst) then error(string(lst) + " is not a list")
  else lst[0];
end;


"
rest(lst) 

Returns the rest of a list, i.e. everything but the first element.

: rest([1, 2, 3]) ==> [2, 3]
: rest([1]) ==> []
: rest([]) ==> []
: rest(NULL) ==> NULL
"
def rest(lst) sublist(lst, 1);


"
is_zero(obj)

Returns TRUE if the obj is zero.

: is_zero(0) ==> TRUE
"
def is_zero(obj) is_numeric(obj) and obj == 0;


"
is_negative(obj)

Returns TRUE if the obj is negative.

: is_negative(-1) ==> TRUE
"
def is_negative(obj) is_numeric(obj) and obj < 0;


"
is_positive(obj)

Returns TRUE if the obj is positive.

: is_positive(1) ==> TRUE
"
def is_positive(obj) is_numeric(obj) and obj > 0;


"
is_alphanumerical(str, min = 0, max = 99999)

Returns TRUE if the string is alphanumerical, i.e. contains only a-z, A-Z and 0-9.
It is possible to specify minimal and maximal length using the min and max optional
parameters.

: is_alphanumerical('Ab12') ==> TRUE
"
def is_alphanumerical(str, min=0, max=99999) is_string(str) and str matches pattern('^[a-zA-Z0-9]{' + min + ',' + max + '}$');


"
is_numerical(str, min = 0, max = 99999)

Returns TRUE if the string is numerical, i.e. contains only 0-9. It is possible to
specify minimal and maximal length using the min and max optional parameters.

: is_numerical('123') ==> TRUE
" 
def is_numerical(str, min=0, max=99999) is_string(str) and str matches pattern('^[0-9]{' + min + ',' + max + '}$'); 


"
is_valid_date(str, fmt='yyyyMMdd')

Returns TRUE if the string represents a valid date. The default format
is yyyyMMdd. It is possible to specify different formats using the fmt
optional parameter.

: is_valid_date('20170304') ==> TRUE
"
def is_valid_date(str, fmt="yyyyMMdd") do
    if not is_string(str) then return FALSE;
    parse_date(str, fmt) != NULL;
end;


"
is_valid_time(str, fmt='HHmm')

Returns TRUE if the string represents a valid time. The default format
is HHmm. It is possible to specify different formats using the fmt
optional parameter.

: is_valid_time('1245') ==> TRUE
: is_valid_time(NULL) ==> FALSE
"
def is_valid_time(str, fmt="HHmm") do
    if not is_string(str) then return FALSE;
    parse_date(str, fmt) != NULL;
end;


"
reverse_list(list)

Returns a reversed copy of a list.

: reverse_list([1, 2, 3]) ==> [3, 2, 1]
: reverse_list(NULL) ==> NULL
"
def reverse_list(list) do
  if is_null(list) then return NULL;
  def result = [];
  for element in list do
    result = [element] + result
  end;
  result 
end;


"
reverse_string(str)

Returns a reversed copy of a string.

: reverse_string('abc') ==> 'cba'
"
def reverse_string(str) do
  if is_null(str) then return NULL;
  def result = "";
  for ch in str do
    result = ch + result
  end;
  result
end;


"
reverse(obj)

Returns a reversed copy of a string or a list.

: reverse([1, 2, 3]) ==> [3, 2, 1]
: reverse('abc') ==> 'cba'
"
def reverse(obj) do
  if is_string(obj) then reverse_string(obj)
  if is_list(obj) then reverse_list(obj)
  else error("cannot reverse " + string(obj))
end;


"
reduce(list, func)

Reduces a list by successively applying the binary function func to
partial results and list elements.

: reduce([1, 2, 3, 4], add) ==> 10 
: reduce(NULL, add) ==> NULL
"
def reduce(list, func) do
  if is_null(list) then return NULL;
  if not is_list(list) then error(string(list) + " is not a list")
  if length(list) == 0 then error("Cannot reduce empty list")
  if length(list) == 1 then return list[0]
  else do
    def result = list[0];
    for element in sublist(list, 1) do
      result = func(result, element)
    end;
    result;
  end;
end;


"
prod(list) 

Returns the product of a list of numbers.

: prod([1, 2, 3]) ==> 6
: prod(range(1, 10)) ==> 362880
"
def prod(list) reduce(list, mul);


"
log2(x)

Returns the logarithm of x to base 2.

: log2(1024) ==> 10
"
def log2(x) do
  if not is_numeric(x) then error(string(x) + " is not numeric")
  else round(log(x) / log(2), 12);
end;


"
log10(x)

Returns the logarithm of x to base 10.

: log10(1000) ==> 3
"
def log10(x) do
  if not is_numeric(x) then error(string(x) + " is not numeric")
  else round(log(x) / log(10), 12);
end;


"
substitute(obj, idx, value)

If obj is a list or string, returns a list or string with the element
at index idx replaced by value.

: substitute('abcd', 2, 'x') ==> 'abxd'
: substitute([1, 2, 3, 4], 2, 'x') ==> [1, 2, 'x', 4] 
"
def substitute(obj, idx, value) do
  if is_string(obj) then substr(obj, 0, idx) + value + substr(obj, idx + 1)
  if is_list(obj) then sublist(obj, 0, idx) + value + sublist(obj, idx + 1)
  else error('Cannot substitute in ' + string(obj))
end;


"
grep(lst, pat)

Returns the sublist of list lst, that contains only entries,
that match the regular expression pattern pat.

If pat does not contain ^ and $, then the prefix ^.* and the postfix .*$
are added to the pattern, so that the pattern matches partially.

: grep(['one', 'two', 'three'], //e//) ==> ['one', 'three']
: grep(['one', 'two', 'three'], //^one$//) ==> ['one']
"
def grep(lst, pat) do
  def pat_ = string(pat);
  if not str_contains(pat_, '^') and not str_contains(pat_, '$') then do
    pat_ = '^.*' + pat_ + '.*$';
  end; 
  return [element for element in lst if str_matches(element, pattern(pat_))]
end;


"
interval(a, b)

Returns the interval of integers between a and b, inclusive.

: interval(1, 10) ==> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
: interval(1, 1) ==> [1]
"
def interval(a, b) do
    return [n for n in range(a, b + 1)]
end;


"
label_data(labels, data)

Creates a map that labels the data with the
given labels.

Labels and data must be two lists of equal
length. Labels must be unique.

: label_data(['a', 'b', 'c'], [1, 2, 3]) ==> <<<'a' => 1, 'b' => 2, 'c' => 3>>>
"
def label_data(labels, data) do
    zip_map(labels, data);
end;


"
any(lst, predicate)
any(lst)

Returns TRUE, if the predicate function returns
TRUE for any element of the list.

If no predicate function is passed, the list must
contain boolean values.

: any([1, 2, 3], fn(n) n == 3) ==> TRUE
: any([1, 2, 3], fn(n) n == 4) ==> FALSE
: any([TRUE, TRUE, TRUE]) ==> TRUE
: any([TRUE, FALSE, TRUE]) ==> TRUE
: any([e >= 2 for e in [2, 3, 4]]) ==> TRUE
: any([e >= 2 for e in [1, 3, 4]]) ==> TRUE
"
def any(lst, pred = fn(x) x) do
    for element in lst do
        if pred(element) then return TRUE;
    end;
    return FALSE;
end;


"
all(lst, predicate)
all(lst)

Returns TRUE, if the predicate function returns
TRUE for all elements of the list.

If no predicate function is passed, the list must
contain boolean values.

: all([1, 2, 3], fn(n) n <= 3) ==> TRUE
: all([1, 2, 3], fn(n) n <  3) ==> FALSE
: all([TRUE, TRUE, TRUE]) ==> TRUE
: all([TRUE, FALSE, TRUE]) ==> FALSE
: all([e >= 2 for e in [2, 3, 4]]) ==> TRUE
: all([e >= 2 for e in [1, 3, 4]]) ==> FALSE
"
def all(lst, pred = fn(x) x) do
    for element in lst do
        if not pred(element) then return FALSE;
    end;
    return TRUE;
end;


"
join(sep, lst)

Returns a string containing all elements of the list lst
separated by the string sep.

: join('|', [1, 2, 3]) ==> '1|2|3'
: join('--', ['one', 'world']) ==> 'one--world'
: join('|', []) ==> ''
: join('|', [1]) ==> '1'
"
def join(sep, lst) do
    def result = "";
    for element in lst do
        result = result + sep + string(element);
    end;
    return substr(result, length(sep));
end;


"
q(lst)

Returns a string containing all elements of the list lst
separated by a pipe character.

: q([1, 2, 3]) ==> '1|2|3'
: q([]) ==> ''
"
def q(lst) do
    return join("|", lst);
end;


"
esc(str)

Escapes the characters <, > and & by their HTML entities.

: esc('a<b') ==> 'a&lt;b'
: esc('<code>') ==> '&lt;code&gt;'
"
def esc(str) do
    return replace(replace(replace(str, '&', '&amp;'), '<', '&lt;'), '>', '&gt;');
end;


"
map_list(func, lst)

Returns a list where each element is the corresponding
element of lst with func applied. Thus, the elements of
the list are mapped using the function func to new values.

: map_list(fn(x) 2 * x, [1, 2, 3]) ==> [2, 4, 6]
: map_list(fn(x) '*' + x + '*', ['one', 'two', 'three']) ==> ['*one*', '*two*', '*three*']
"
def map_list(func, lst) do
    return [func(element) for element in lst];
end;


"
date_year(value)

Extracts the year part from the given date value and
returns it as an integer. The value will be converted
to a date value using the date function.

: date_year('20190102') ==> 2019
"
def date_year(value) do
    return int(format_date(date(value), fmt = 'yyyy'));
end;


"
date_month(value)

Extracts the month part from the given date value and
returns it as an integer. The value will be converted
to a date value using the date function.

: date_month('20190102') ==> 01
"
def date_month(value) do
    return int(format_date(date(value), fmt = 'MM'));
end;


"
date_day(value)

Extracts the day part from the given date value and
returns it as an integer. The value will be converted
to a date value using the date function.

: date_day('20190102') ==> 02
"
def date_day(value) do
    return int(format_date(date(value), fmt = 'dd'));
end;


"
date_hour(value)

Extracts the hour part from the given date value and
returns it as an integer. The value will be converted
to a date value using the date function.

: date_hour('2019010212') ==> 12
"
def date_hour(value) do
    return int(format_date(date(value), fmt = 'HH'));
end;


"
date_minute(value)

Extracts the hour part from the given date value and
returns it as an integer.

: date_minute(parse_date('201901021223', fmt='yyyyMMddHHmm')) ==> 23
"
def date_minute(value) do
    return int(format_date(date(value), fmt = 'mm'));
end;


"
date_second(value)

Extracts the second part from the given date value and
returns it as an integer.

: date_second(parse_date('20190102122345', fmt='yyyyMMddHHmmss')) ==> 45
"
def date_second(value) do
    return int(format_date(date(value), fmt = 'ss'));
end;


"
map_get(m, k, default_value=NULL)

If the map m contains the key k, then the corresponding
value is returned. Otherwise, the default_value is
returned.

: map_get(map([['a', 1], ['b', 2]]), 'a') ==> 1
: map_get(map([['a', 1], ['b', 2]]), 'b') ==> 2
: map_get(map([['a', 1], ['b', 2]]), 'c') ==> NULL
: map_get(map([['a', 1], ['b', 2]]), 'c', default_value = 9) ==> 9
"
def map_get(m, k, default_value=NULL) do
    if k in m then m[k] else default_value;
end;


"
map_get_pattern(m, k, default_value=NULL)

The map m is assumed to contain regex patterns as keys.
If the key k matches one of the regex patterns, then
the corresponding value is returned. Otherwise, the
default_value is returned.

If more than one pattern matches the key k, then it is
undefined, which pattern is selected for retrieving its
value.

: map_get_pattern(map([[//[ab]//, 1], [//[cd]//, 2]]), 'a') ==> 1
: map_get_pattern(map([[//[ab]//, 1], [//[cd]//, 2]]), 'b') ==> 1
: map_get_pattern(map([[//[ab]//, 1], [//[cd]//, 2]]), 'c') ==> 2
: map_get_pattern(map([[//[ab]//, 1], [//[cd]//, 2]]), 'd') ==> 2
: map_get_pattern(map([[//[ab]//, 1], [//[cd]//, 2]]), 'e') ==> NULL
"
def map_get_pattern(m, k, default_value=NULL) do
    for pattern in set(m) do
        if str_matches(k, pattern) then do
            return m[pattern];
        end;
    end;
    return default_value;
end;

"
enumerate(obj)

Enumerates the contents of a list, set or map.

The result for a list is a list of pairs (index, value).

The result for a map is a list of pairs (key, value).

A set cannot be enumerated, since it does not have a
well defined ordering of its elements. If you wish to
enumerate a set, then convert it into a list and sort it
first, e.g. enumerate(sorted(list(some_set))). But be aware
that this involves a costly sort operation, maybe you
should think about using a list instead of the set in
the first place.

For other data types, an error is thrown.

Typically, you would use this in a for loop, e.g.
  for entry in enumerate(some_list) do
    println('index = ' + entry[0] + ', value = ' + entry[1]); 
  end;

: enumerate(['a', 'b', 'c']) ==> [[0, 'a'], [1, 'b'], [2, 'c']]
: enumerate(map([['a', 5], ['b', 6], ['c', 7]])) ==> [['a', 5], ['b', 6], ['c', 7]]
"
def enumerate(obj) do
    if is_list(obj) then [[i, obj[i]] for i in range(length(obj))]
    if is_map(obj) then [[key, obj[key]] for key in set(obj)]
    else error("can only enumerate list, set and map objects")
end;


"
Partially applies the function f with the argument arg.
This returns another function which takes the remaining
args of the original function f.

: def f(a, b, c) [a, b, c]; def g = curry(f, 1); g(2, 3) ==> [1, 2, 3]
"
def curry(f, arg) fn(args...) f(arg, ...args...);


"
Applies the function with the arguments in the list args.

: apply(fn(a, b, c) a + b + c, [1, 2, 3]) ==> 6
"
def apply(f, args) f(...args);


"
Makes the elements of the list unique, by discarding duplicates,
while retaining the original ordering. The first occurence of each
duplicate is retained.

: unique([1, 4, 2, 3, 3, 4, 5]) ==> [1, 4, 2, 3, 5]
: ['a1', 'b2', 'c2', 'd3'] !> unique(key = fn(x) x[1]) ==> ['a1', 'b2', 'd3']
"
def unique(lst, key = identity) do
  def result = [];
  def s = <<>>;
  for item in lst do
    def val = key(item);
    if val in s then continue;
    s !> append(val);
    result !> append(item);
  end;
  result;
end;


"
Returns a filtered copy of the list by discarding
all elements for which the predicate returns FALSE.

: [1, 2, 3, 4, 5, 6] !> filter(fn(x) x % 2 == 0) ==> [2, 4, 6]
: [1, 'one', 2.2, TRUE, sum] !> filter(is_numeric) ==> [1, 2.2]
: [['abc', 1], ['bbc', 2], ['acc', 3]] !> filter(fn(x) x !> starts_with('a'), key = fn(x) x[0]) ==> [['abc', 1], ['acc', 3]]
"
def filter(lst, predicate, key = identity) do
  def result = [];
  for element in lst do
    def val = key(element);
    if predicate(val) then result !> append(element);
  end;
  return result;
end;


"
Returns TRUE if the number is even.

: is_even(2) ==> TRUE
: is_even(3) ==> FALSE
"
def is_even(n) do
  if not is_numeric(n) then return FALSE;
  return n % 2 == 0;
end;


"
Returns TRUE if the number is odd.

: is_odd(2) ==> FALSE
: is_odd(3) ==> TRUE
"
def is_odd(n) do
  if not is_numeric(n) then return FALSE;
  return n % 2 == 1;
end;
