# Copyright (c) 2021 Damian Brunold, Gesundheitsdirektion Kanton ZÃ¼rich
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

require sys unqualified;
require core unqualified;


"
is_list(obj) 

Returns TRUE if the object is of type list.

: is_list([1, 2, 3]) ==> TRUE
"
def is_list(obj) type(obj) == 'list';


"
is_string(obj) 

Returns TRUE if the object is of type string.

: is_string('abc') ==> TRUE
"
def is_string(obj) type(obj) == 'string';


"
is_int(obj) 

Returns TRUE if the object is of type int.

: is_int(123) ==> TRUE
"
def is_int(obj) type(obj) == 'int';


"
is_decimal(obj) 

Returns TRUE if the object is of type decimal.

: is_decimal(123.45) ==> TRUE
"
def is_decimal(obj) type(obj) == 'decimal';


"
is_numeric(obj) 

Returns TRUE if the object is of type numeric. Numeric
types are int and decimal.

: is_numeric(123) ==> TRUE
: is_numeric(123.45) ==> TRUE
"
def is_numeric(obj) is_int(obj) or is_decimal(obj);


"
is_boolean(obj) 

Returns TRUE if the object is of type boolean.

: is_boolean(1 == 2) ==> TRUE
"
def is_boolean(obj) type(obj) == 'boolean';


"
is_set(obj) 

Returns TRUE if the object is of type set.

: is_set(set([1, 2, 3])) ==> TRUE
"
def is_set(obj) type(obj) == 'set';


"
is_map(obj) 

Returns TRUE if the object is of type map.

: is_map(map([['a', 1], ['b', 2]])) ==> TRUE
"
def is_map(obj) type(obj) == 'map';


"
is_object(obj) 

Returns TRUE if the object is of type object.

: is_object(object()) ==> TRUE
"
def is_object(obj) type(obj) == 'object';


"
is_func(obj) 

Returns TRUE if the object is of type func.

: is_func(fn(x) 2 * x) ==> TRUE
: is_func(sum) ==> TRUE
"
def is_func(obj) type(obj) == 'func';


"
non_zero(a, b) 

Returns the value a, if a is a non-zero integer, otherwise returns b.

: non_zero(1, 2) ==> 1
: non_zero(0, 2) ==> 2
"
def non_zero(a, b) do
  if int(a) == 0 then b
  else a
end;


"
non_empty(a, b) 

Returns the value a, if a is a non-empty string, otherwise returns b.

: non_empty('a', 'b') ==> 'a'
: non_empty('', 'b') ==> 'b'
"
def non_empty(a, b) do
  if a == '' then b
  else a
end;


"
const(val) 

Returns a function that returns a constant value, regardless of the argument used.

: def f = const(2); f(1) ==> 2
: def f = const(2); f('x') ==> 2
"
def const(val) fn(a) val;


"
min(a, b, key = identity) 
min(a, key = identity)

Returns the minimum of the values a, b. 

Returns the mininmum value of the list a.

The optional key parameter takes a function with one parameter, which 
is used to get the value from a and b that is used for the comparison. 
Default key is the identity function.

: min(1, 2) ==> 1
: min([1, 'z'], [2, 'a'], key = fn(x) x[1]) ==> [2, 'a']
: min([1, 3, 2, 4, 2]) ==> 1
"
def min(a, b = NULL, key = identity) do
  if is_list(a) and is_null(b) then do
    def min_item = a[0];
    def min_val = key(min_item);
    for item in a do
      def val = key(item);
      if val < min_val then do
        min_val = val;
        min_item = item;
      end;
    end;
    return min_item;
  end;
  if key(a) < key(b) then a
  else b;
end;


"
max(a, b, key = identity) 
max(a, key = identity)

Returns the maximum of the values a, b. 

Returns the maximum value of the list a.

The optional key parameter takes a function with one parameter, which 
is used to get the value from a and b that is used for the comparison. 
Default key is the identity function.

: max(1, 2) ==> 2
: max([1, 'z'], [2, 'a'], key = fn(x) x[1]) ==> [1, 'z']
: max([1, 3, 2, 4, 2]) ==> 4
"
def max(a, b = NULL, key = identity) do
  if is_list(a) and is_null(b)then do
    def max_item = a[0];
    def max_val = key(max_item);
    for item in a do
      def val = key(item);
      if val > max_val then do
        max_val = val;
        max_item = item;
      end;
    end;
    return max_item;
  end;
  if key(a) > key(b) then a
  else b;
end;


"
abs(n) 

Returns the absolute value of n.

: abs(2) ==> 2
: abs(-3) ==> 3
"
def abs(n) do
  if is_null(n) then NULL
  if not is_numeric(n) then error(string(n) + " is not numerical")
  if n < 0 then - n 
  else n
end;


"
sign(n) 

Returns the signum of n

: sign(2) ==> 1
: sign(-3) ==> -1
"
def sign(n) do
  if is_null(n) then NULL
  if not is_numeric(n) then error(string(n) + " is not numerical")
  if n < 0 then -1
  if n > 0 then 1 
  else 0;
end;


"
is_zero(obj)

Returns TRUE if the obj is zero.

: is_zero(0) ==> TRUE
"
def is_zero(obj) is_numeric(obj) and obj == 0;


"
is_negative(obj)

Returns TRUE if the obj is negative.

: is_negative(-1) ==> TRUE
"
def is_negative(obj) is_numeric(obj) and obj < 0;


"
is_positive(obj)

Returns TRUE if the obj is positive.

: is_positive(1) ==> TRUE
"
def is_positive(obj) is_numeric(obj) and obj > 0;


"
is_alphanumerical(str, min = 0, max = 99999)

Returns TRUE if the string is alphanumerical, i.e. contains only a-z, A-Z and 0-9.
It is possible to specify minimal and maximal length using the min and max optional
parameters.

: is_alphanumerical('Ab12') ==> TRUE
"
def is_alphanumerical(str, min=0, max=99999) is_string(str) and str matches pattern('^[a-zA-Z0-9]{' + min + ',' + max + '}$');


"
is_numerical(str, min = 0, max = 99999)

Returns TRUE if the string is numerical, i.e. contains only 0-9. It is possible to
specify minimal and maximal length using the min and max optional parameters.

: is_numerical('123') ==> TRUE
" 
def is_numerical(str, min=0, max=99999) is_string(str) and str matches pattern('^[0-9]{' + min + ',' + max + '}$'); 


"
is_valid_date(str, fmt='yyyyMMdd')

Returns TRUE if the string represents a valid date. The default format
is yyyyMMdd. It is possible to specify different formats using the fmt
optional parameter.

: is_valid_date('20170304') ==> TRUE
: is_valid_date('2017030412') ==> FALSE
: is_valid_date('20170399') ==> FALSE
"
def is_valid_date(str, fmt="yyyyMMdd") do
    if not is_string(str) then return FALSE;
    parse_date(str, fmt) != NULL;
end;


"
is_valid_time(str, fmt='HHmm')

Returns TRUE if the string represents a valid time. The default format
is HHmm. It is possible to specify different formats using the fmt
optional parameter.

: is_valid_time('1245') ==> TRUE
: is_valid_time(NULL) ==> FALSE
"
def is_valid_time(str, fmt="HHmm") do
    if not is_string(str) then return FALSE;
    parse_date(str, fmt) != NULL;
end;


"
reverse_string(str)

Returns a reversed copy of a string.

: reverse_string('abc') ==> 'cba'
: reverse_string(NULL) ==> NULL
: reverse_string(12) ==> NULL
"
def reverse_string(str) do
  if not is_string(str) then return NULL;
  def result = "";
  for ch in str do
    result = ch + result
  end;
  result
end;


"
substitute(obj, idx, value)

If obj is a list or string, returns a list or string with the element
at index idx replaced by value.

: substitute('abcd', 2, 'x') ==> 'abxd'
: substitute([1, 2, 3, 4], 2, 'x') ==> [1, 2, 'x', 4] 
"
def substitute(obj, idx, value) do
  if is_string(obj) then substr(obj, 0, idx) + value + substr(obj, idx + 1)
  if is_list(obj) then sublist(obj, 0, idx) + value + sublist(obj, idx + 1)
  else error('Cannot substitute in ' + string(obj))
end;


"
interval(a, b)

Returns the interval of integers between a and b, inclusive.

: interval(1, 10) ==> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
: interval(1, 1) ==> [1]
"
def interval(a, b) do
    return [n for n in range(a, b + 1)]
end;


"
label_data(labels, data)

Creates a map that labels the data with the
given labels.

Labels and data must be two lists of equal
length. Labels must be unique.

: label_data(['a', 'b', 'c'], [1, 2, 3]) ==> <<<'a' => 1, 'b' => 2, 'c' => 3>>>
"
def label_data(labels, data) do
    zip_map(labels, data);
end;


"
any(lst, predicate)
any(lst)

Returns TRUE, if the predicate function returns
TRUE for any element of the list.

If no predicate function is passed, the list must
contain boolean values.

: any([1, 2, 3], fn(n) n == 3) ==> TRUE
: any([1, 2, 3], fn(n) n == 4) ==> FALSE
: any([TRUE, TRUE, TRUE]) ==> TRUE
: any([TRUE, FALSE, TRUE]) ==> TRUE
: any([e >= 2 for e in [2, 3, 4]]) ==> TRUE
: any([e >= 2 for e in [1, 3, 4]]) ==> TRUE
"
def any(lst, pred = fn(x) x) do
    for element in lst do
        if pred(element) then return TRUE;
    end;
    return FALSE;
end;


"
all(lst, predicate)
all(lst)

Returns TRUE, if the predicate function returns
TRUE for all elements of the list.

If no predicate function is passed, the list must
contain boolean values.

: all([1, 2, 3], fn(n) n <= 3) ==> TRUE
: all([1, 2, 3], fn(n) n <  3) ==> FALSE
: all([TRUE, TRUE, TRUE]) ==> TRUE
: all([TRUE, FALSE, TRUE]) ==> FALSE
: all([e >= 2 for e in [2, 3, 4]]) ==> TRUE
: all([e >= 2 for e in [1, 3, 4]]) ==> FALSE
"
def all(lst, pred = fn(x) x) do
    for element in lst do
        if not pred(element) then return FALSE;
    end;
    return TRUE;
end;


"
join(lst, sep = ' ')

Returns a string containing all elements of the list lst
separated by the string sep.

: join([1, 2, 3], '|') ==> '1|2|3'
: join(['one', 'world'], '--') ==> 'one--world'
: join([], '|') ==> ''
: join([1], '|') ==> '1'
: join('|', [1, 2, 3]) ==> '1|2|3'
"
def join(lst, sep) do
    if type(lst) == "string" then [lst, sep] = [sep, lst];
    def result = "";
    for element in lst do
        result = result + sep + string(element);
    end;
    return substr(result, length(sep));
end;


"
q(lst)

Returns a string containing all elements of the list lst
separated by a pipe character.

: q([1, 2, 3]) ==> '1|2|3'
: q([]) ==> ''
"
def q(lst) do
    return join("|", lst);
end;


"
esc(str)

Escapes the characters <, > and & by their HTML entities.

: esc('a<b') ==> 'a&lt;b'
: esc('<code>') ==> '&lt;code&gt;'
"
def esc(str) do
    return replace(replace(replace(str, '&', '&amp;'), '<', '&lt;'), '>', '&gt;');
end;


"
date_year(value)

Extracts the year part from the given date value and
returns it as an integer. The value will be converted
to a date value using the date function.

: date_year('20190102') ==> 2019
"
def date_year(value) do
    return int(format_date(date(value), fmt = 'yyyy'));
end;


"
date_month(value)

Extracts the month part from the given date value and
returns it as an integer. The value will be converted
to a date value using the date function.

: date_month('20190102') ==> 01
"
def date_month(value) do
    return int(format_date(date(value), fmt = 'MM'));
end;


"
date_day(value)

Extracts the day part from the given date value and
returns it as an integer. The value will be converted
to a date value using the date function.

: date_day('20190102') ==> 02
"
def date_day(value) do
    return int(format_date(date(value), fmt = 'dd'));
end;


"
date_hour(value)

Extracts the hour part from the given date value and
returns it as an integer. The value will be converted
to a date value using the date function.

: date_hour('2019010212') ==> 12
"
def date_hour(value) do
    return int(format_date(date(value), fmt = 'HH'));
end;


"
date_minute(value)

Extracts the hour part from the given date value and
returns it as an integer.

: date_minute(parse_date('201901021223', fmt='yyyyMMddHHmm')) ==> 23
"
def date_minute(value) do
    return int(format_date(date(value), fmt = 'mm'));
end;


"
date_second(value)

Extracts the second part from the given date value and
returns it as an integer.

: date_second(parse_date('20190102122345', fmt='yyyyMMddHHmmss')) ==> 45
"
def date_second(value) do
    return int(format_date(date(value), fmt = 'ss'));
end;


"
map_get(m, k, default_value=NULL)

If the map m contains the key k, then the corresponding
value is returned. Otherwise, the default_value is
returned.

: map_get(<<<a => 1, b => 2>>>, 'a') ==> 1
: map_get(<<<a => 1, b => 2>>>, 'b') ==> 2
: map_get(<<<a => 1, b => 2>>>, 'c') ==> NULL
: map_get(<<<a => 1, b => 2>>>, 'c', default_value = 9) ==> 9
"
def map_get(m, k, default_value=NULL) do
    if k in m then m[k] else default_value;
end;


"
map_get_pattern(m, k, default_value=NULL)

The map m is assumed to contain regex patterns as keys.
If the key k matches one of the regex patterns, then
the corresponding value is returned. Otherwise, the
default_value is returned.

If more than one pattern matches the key k, then it is
undefined, which pattern is selected for retrieving its
value.

: map_get_pattern(<<<//[ab]// => 1, //[cd]// => 2>>>, 'a') ==> 1
: map_get_pattern(<<<//[ab]// => 1, //[cd]// => 2>>>, 'b') ==> 1
: map_get_pattern(<<<//[ab]// => 1, //[cd]// => 2>>>, 'c') ==> 2
: map_get_pattern(<<<//[ab]// => 1, //[cd]// => 2>>>, 'd') ==> 2
: map_get_pattern(<<<//[ab]// => 1, //[cd]// => 2>>>, 'e') ==> NULL
"
def map_get_pattern(m, k, default_value=NULL) do
    for pattern in set(m) if str_matches(k, pattern) then return m[pattern];
    return default_value;
end;


"
curry(f, arg)

Partially applies the function f with the argument arg.
This returns another function which takes the remaining
args of the original function f.

: def f(a, b, c) [a, b, c]; def g = curry(f, 1); g(2, 3) ==> [1, 2, 3]
"
def curry(f, arg) fn(args...) f(arg, ...args...);


"
apply(f, args)

Applies the function with the arguments in the list args.

: apply(fn(a, b, c) a + b + c, [1, 2, 3]) ==> 6
"
def apply(f, args) f(...args);


"
lines(str)

Splits the string str into lines and returns them as a list.

: lines('a\\nb c\\r\\nd') ==> ['a', 'b c', 'd']
"
def lines(str) do
  split(str, '\\r?\\n');
end;


"
words(str)

Splits the string str into words and returns them as a list.

: words('one  two\\tthree four') ==> ['one', 'two', 'three', 'four']
"
def words(str) do
  split(str, '[ \\t\\r\\n]+');
end;


"
unlines(lst)

Joins a list of lines into one string.

: unlines(['a', 'b', 'c']) ==> 'a\\nb\\nc'
"
def unlines(lst) do
  lst !> join(sep = '\n');
end;


"
unwords(lst)

Joins a list of words into one string.

: unwords(['a', 'b', 'c']) ==> 'a b c'
"
def unwords(lst) do
  lst !> join(sep = ' ');
end;


"
read_file(filename, encoding = 'utf-8')

Opens a file, reads the contents as a single
string, closes the file and returns the string.
"
def read_file(filename, encoding = 'utf-8') do
  def infile = file_input(filename, encoding);
  do
      return read_all(infile);
  finally
      close(infile);
  end;
end;


"
enumerate(obj)

Enumerates the contents of a list, set or map.

The result for a list is a list of pairs (index, value).

The result for a map is a list of pairs (key, value).

A set cannot be enumerated, since it does not have a
well defined ordering of its elements. If you wish to
enumerate a set, then convert it into a list and sort it
first, e.g. enumerate(sorted(list(some_set))). But be aware
that this involves a costly sort operation, maybe you
should think about using a list instead of the set in
the first place.

For other data types, an error is thrown.

Typically, you would use this in a for loop, e.g.
  for entry in enumerate(some_list) do
    println('index = ' + entry[0] + ', value = ' + entry[1]);
  end;

: enumerate(['a', 'b', 'c']) ==> [[0, 'a'], [1, 'b'], [2, 'c']]
: enumerate(<<<a => 5, b => 6, c => 7>>>) ==> [['a', 5], ['b', 6], ['c', 7]]
"
def enumerate(obj) do
    if is_list(obj) then [[i, obj[i]] for i in range(length(obj))]
    elif is_map(obj) then [[key, obj[key]] for key in set(obj)]
    elif is_object(obj) then [[member, obj[member]] for member in obj]
    else error("can only enumerate list, set and map objects")
end;


"
sprintf(fmt, args...)

Formats a string format using the provided args. Each
value can be referred to in the fmt string using the
{0} syntax, where 0 means the first argument passed.

This uses internally the s function. See there for
an explanation of available formatting suffixes.

: sprintf('{0} {1}', 1, 2) ==> '1 2'
: sprintf('{0} {1}', 'a', 'b') ==> 'a b'
: sprintf('{0#5} {1#5}', 1, 2) ==> '    1     2'
: sprintf('{0#-5} {1#-5}', 1, 2) ==> '1     2    '
: sprintf('{0#05} {1#05}', 1, 2) ==> '00001 00002'
: sprintf('{0#.4}', PI) ==> '3.1416'
"
def sprintf(fmt, args...) do
    for entry in enumerate(args...) do
        if is_string(entry[1]) then entry[1] = "'" + entry[1] + "'";
        fmt = fmt !> replace('{' + entry[0] + '}', '{x' + entry[1] + '}') !> replace('{' + entry[0] + '#', '{x' + entry[1] + '#');
    end;
    return s(fmt !> replace('{x', '{'));
end;


"
count(obj, elem)

Returns the number of times, elem is contained in obj.
Obj can be a string, list or map. If it is a map,
then the values of the map, not the keys are checked.

: count([1, 2, 2, 2, 3, 4], 2) ==> 3
: count(<<<1 => 1, 1 => 2, 2 => 2, 3 => 3>>>, 2) ==> 2
: count('122234', '2') ==> 3
"
def count(obj, elem) do
    def result = 0;
    for e in obj do
        if e == elem then result += 1;
    end;
    return result;
end;


"
chunks(obj, chunk_size)

Splits the obj into a list where each item is of size chunk_size,
except perhaps the last, which may be smaller. Obj can be a string
or a list.

: range(9) !> chunks(3) ==> [[0, 1, 2], [3, 4, 5], [6, 7, 8]]
: range(10) !> chunks(3) ==> [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9]]
: 'abcdefghi' !> chunks(3) ==> ['abc', 'def', 'ghi']
"
def chunks(obj, chunk_size) do
    def result = [];
    if (is_list(obj)) then do
      while length(obj) > chunk_size do
        result !> append(obj !> sublist(0, chunk_size));
        obj = obj !> sublist(chunk_size);
      end;
      result !> append(obj);
    end if is_string(obj) then do
      while length(obj) > chunk_size do
          result !> append(obj !> substr(0, chunk_size));
          obj = obj !> substr(chunk_size);
      end;
      result !> append(obj);
    end else error("cannot split obj of type " + type(obj));
    return result;
end;
